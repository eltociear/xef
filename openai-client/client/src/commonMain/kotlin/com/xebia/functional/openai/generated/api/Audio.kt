/**
 * Please note: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
@file:Suppress("ArrayInDataClass", "EnumEntryName", "RemoveRedundantQualifierName", "UnusedImport")

package com.xebia.functional.openai.generated.api

import com.xebia.functional.openai.Config
import com.xebia.functional.openai.UploadFile
import com.xebia.functional.openai.appendGen
import com.xebia.functional.openai.generated.api.Audio.*
import com.xebia.functional.openai.generated.model.CreateSpeechRequest
import com.xebia.functional.openai.generated.model.CreateTranscriptionRequestModel
import com.xebia.functional.openai.generated.model.CreateTranscriptionResponse
import com.xebia.functional.openai.generated.model.CreateTranslationResponse
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.request.HttpRequestBuilder
import io.ktor.client.request.forms.formData
import io.ktor.client.request.request
import io.ktor.client.request.setBody
import io.ktor.client.statement.HttpResponse
import io.ktor.http.ContentType
import io.ktor.http.HttpMethod
import io.ktor.http.contentType
import io.ktor.http.path
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*
import kotlinx.serialization.json.Json

/**  */
interface Audio {

  /**
   * Generates audio from the input text.
   *
   * @param createSpeechRequest
   * @param configure optional configuration for the request, allows overriding the default
   *   configuration.
   * @return UploadFile
   */
  suspend fun createSpeech(
    createSpeechRequest: CreateSpeechRequest,
    configure: HttpRequestBuilder.() -> Unit = {}
  ): HttpResponse

  /** enum for parameter responseFormat */
  @Serializable
  enum class ResponseFormatCreateTranscription(val value: kotlin.String) {

    @SerialName(value = "json") json("json"),
    @SerialName(value = "text") text("text"),
    @SerialName(value = "srt") srt("srt"),
    @SerialName(value = "verbose_json") verbose_json("verbose_json"),
    @SerialName(value = "vtt") vtt("vtt")
  }

  /** enum for parameter timestampGranularities */
  @Serializable
  enum class TimestampGranularitiesCreateTranscription(val value: kotlin.String) {

    @SerialName(value = "word") word("word"),
    @SerialName(value = "segment") segment("segment")
  }

  /**
   * Transcribes audio into the input language.
   *
   * @param file The audio file object (not file name) to transcribe, in one of these formats: flac,
   *   mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
   * @param model
   * @param language The language of the input audio. Supplying the input language in
   *   [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve
   *   accuracy and latency. (optional)
   * @param prompt An optional text to guide the model&#39;s style or continue a previous audio
   *   segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
   *   (optional)
   * @param responseFormat The format of the transcript output, in one of these options:
   *   &#x60;json&#x60;, &#x60;text&#x60;, &#x60;srt&#x60;, &#x60;verbose_json&#x60;, or
   *   &#x60;vtt&#x60;. (optional, default to json)
   * @param temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make
   *   the output more random, while lower values like 0.2 will make it more focused and
   *   deterministic. If set to 0, the model will use
   *   [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase
   *   the temperature until certain thresholds are hit. (optional, default to 0)
   * @param timestampGranularities The timestamp granularities to populate for this transcription.
   *   Any of these options: &#x60;word&#x60;, or &#x60;segment&#x60;. Note: There is no additional
   *   latency for segment timestamps, but generating word timestamps incurs additional latency.
   *   (optional)
   * @param configure optional configuration for the request, allows overriding the default
   *   configuration.
   * @return CreateTranscriptionResponse
   */
  suspend fun createTranscription(
    file: UploadFile,
    model: CreateTranscriptionRequestModel,
    language: kotlin.String? = null,
    prompt: kotlin.String? = null,
    responseFormat: ResponseFormatCreateTranscription? = ResponseFormatCreateTranscription.json,
    temperature: kotlin.Double? = 0.toDouble(),
    timestampGranularities: kotlin.collections.List<TimestampGranularitiesCreateTranscription>? =
      null,
    configure: HttpRequestBuilder.() -> Unit = {}
  ): CreateTranscriptionResponse

  /**
   * Translates audio into English.
   *
   * @param file The audio file object (not file name) translate, in one of these formats: flac,
   *   mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
   * @param model
   * @param prompt An optional text to guide the model&#39;s style or continue a previous audio
   *   segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English. (optional)
   * @param responseFormat The format of the transcript output, in one of these options:
   *   &#x60;json&#x60;, &#x60;text&#x60;, &#x60;srt&#x60;, &#x60;verbose_json&#x60;, or
   *   &#x60;vtt&#x60;. (optional, default to "json")
   * @param temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make
   *   the output more random, while lower values like 0.2 will make it more focused and
   *   deterministic. If set to 0, the model will use
   *   [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase
   *   the temperature until certain thresholds are hit. (optional, default to 0)
   * @param configure optional configuration for the request, allows overriding the default
   *   configuration.
   * @return CreateTranslationResponse
   */
  suspend fun createTranslation(
    file: UploadFile,
    model: CreateTranscriptionRequestModel,
    prompt: kotlin.String? = null,
    responseFormat: kotlin.String? = "json",
    temperature: kotlin.Double? = 0.toDouble(),
    configure: HttpRequestBuilder.() -> Unit = {}
  ): CreateTranslationResponse
}

fun Audio(client: HttpClient, config: Config): Audio =
  object : Audio {
    override suspend fun createSpeech(
      createSpeechRequest: CreateSpeechRequest,
      configure: HttpRequestBuilder.() -> Unit
    ): HttpResponse =
      client.request {
        configure()
        method = HttpMethod.Post
        contentType(ContentType.Application.Json)
        url { path("audio/speech") }
        setBody(createSpeechRequest)
      }

    override suspend fun createTranscription(
      file: UploadFile,
      model: CreateTranscriptionRequestModel,
      language: kotlin.String?,
      prompt: kotlin.String?,
      responseFormat: ResponseFormatCreateTranscription?,
      temperature: kotlin.Double?,
      timestampGranularities: kotlin.collections.List<TimestampGranularitiesCreateTranscription>?,
      configure: HttpRequestBuilder.() -> Unit
    ): CreateTranscriptionResponse =
      client
        .request {
          configure()
          method = HttpMethod.Post
          contentType(ContentType.Application.Json)
          url { path("audio/transcriptions") }
          setBody(
            formData {
              file?.apply { appendGen("file", file) }
              model?.apply { appendGen("model", model) }
              language?.apply { appendGen("language", language) }
              prompt?.apply { appendGen("prompt", prompt) }
              responseFormat?.apply { appendGen("response_format", responseFormat) }
              temperature?.apply { appendGen("temperature", temperature) }
              timestampGranularities?.onEach { appendGen("timestamp_granularities[][]", it) }
            }
          )
        }
        .body()

    override suspend fun createTranslation(
      file: UploadFile,
      model: CreateTranscriptionRequestModel,
      prompt: kotlin.String?,
      responseFormat: kotlin.String?,
      temperature: kotlin.Double?,
      configure: HttpRequestBuilder.() -> Unit
    ): CreateTranslationResponse =
      client
        .request {
          configure()
          method = HttpMethod.Post
          contentType(ContentType.Application.Json)
          url { path("audio/translations") }
          setBody(
            formData {
              file?.apply { appendGen("file", file) }
              model?.apply { appendGen("model", model) }
              prompt?.apply { appendGen("prompt", prompt) }
              responseFormat?.apply { appendGen("response_format", responseFormat) }
              temperature?.apply { appendGen("temperature", temperature) }
            }
          )
        }
        .body()
  }
