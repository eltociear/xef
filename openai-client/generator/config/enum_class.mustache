{{#isEnum}}import kotlinx.serialization.*
import kotlinx.serialization.builtins.*
import kotlinx.serialization.encoding.*
import kotlin.jvm.JvmStatic
{{#allowableValues}}{{#enumVars}}import com.xebia.functional.openai.generated.model.{{classname}}.Supported.{{#lambda.unquote}}{{&value}}{{/lambda.unquote}}
{{/enumVars}}{{/allowableValues}}

/**
 * {{{description}}}
 *
 * Values: {{#allowableValues}}{{#enumVars}}{{&name}}{{^-last}},{{/-last}}{{/enumVars}}{{/allowableValues}}
 */
// We define a serializer for the parent sum type,
// and then use it to serialize the child types
@Suppress("SERIALIZER_TYPE_INCOMPATIBLE")
@Serializable(with = {{classname}}Serializer::class)
sealed interface {{classname}} {
  {{^isString}}val value: {{{dataType}}}{{/isString}}{{#isString}}val name: kotlin.String{{/isString}}

  @Serializable(with = {{classname}}Serializer::class)
  enum class Supported({{^isString}}override val value: {{{dataType}}}{{/isString}}{{#isString}}name: kotlin.String{{/isString}}) : {{classname}} {
    {{#allowableValues}}{{#enumVars}}@SerialName(value = {{{value}}}) {{#lambda.unquote}}{{&value}}{{/lambda.unquote}}({{#isArray}}{{#isList}}listOf({{{value}}})){{/isList}}{{^isList}}arrayOf({{{value}}})){{/isList}}{{/isArray}}{{^isArray}}{{#isString}}{{#lambda.doublequote}}{{{value}}}{{/lambda.doublequote}}{{/isString}}{{^isString}}{{{value}}}{{/isString}}{{/isArray}}){{^-last}},{{/-last}}{{#-last}};{{/-last}}{{/enumVars}}{{/allowableValues}}

    override fun toString(): kotlin.String = {{^isString}}value.toString(){{/isString}}{{#isString}}name{{/isString}}
  }

  @Serializable(with = {{classname}}Serializer::class)
  data class Custom(override val {{^isString}}value: {{{datatype}}}{{/isString}}{{#isString}}name: kotlin.String{{/isString}}) : {{classname}}

    companion object {
      @JvmStatic
      fun valueOf({{^isString}}value{{/isString}}{{#isString}}name{{/isString}}: {{{dataType}}}): {{classname}} =
        values().firstOrNull { it.name == name } ?: Custom(name)

      {{#allowableValues}}{{#enumVars}}
          inline val {{#lambda.unquote}}{{&value}}{{/lambda.unquote}}: {{classname}}
            get() = Supported.{{#lambda.unquote}}{{&value}}{{/lambda.unquote}}
      {{/enumVars}}{{/allowableValues}}

      @JvmStatic fun values(): List<{{classname}}> = Supported.entries
}

private object {{classname}}Serializer : KSerializer<{{classname}}> {
    private val valueSerializer = {{{dataType}}}.serializer()
    override val descriptor = valueSerializer.descriptor

    override fun deserialize(decoder: Decoder): {{classname}} {
        val value = decoder.decodeSerializableValue(valueSerializer)
        return {{classname}}.valueOf(value)
    }

    override fun serialize(encoder: Encoder, value: {{classname}}) {
        encoder.encodeSerializableValue(valueSerializer, value.{{^isString}}value{{/isString}}{{#isString}}name{{/isString}})
    }
}
{{/isEnum}}